[TOC]



##### AbstractQueuedSynchronizer

###### 类的属性

```java
public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {
    private static final long serialVersionUID = 7373984972572414691L;
    // 同步队列头结点
    private transient volatile Node head;
    // 同步队列尾结点
    private transient volatile Node tail;
    // 锁的状态
    private volatile int state;
    // 自旋超时阈值，单位纳秒
    static final long spinForTimeoutThreshold = 1000L;
}
```

###### Node

```java
static final class Node {
    // 共享模式
    static final Node SHARED = new Node();
    // 独占模式
    static final Node EXCLUSIVE = null;
    // 当前结点由于超时或者interrupt被取消，一经设置，结点无法该表此状态。即该线程不会再次被阻塞
    static final int CANCELLED =  1;
    // 当前结点的后继结点已经（或很快）被阻塞，所以当前结点必须在释放或者取消的时候唤醒它的后继结点
    static final int SIGNAL    = -1;
    // 当前结点在条件队列中
    static final int CONDITION = -2;
    // 表示共享模式同步状态被传播下去
    static final int PROPAGATE = -3;
    // 结点状态，取值0、1、-1、-2、-3
    volatile int waitStatus;
    // 同步队列当前结点的前驱结点
    volatile Node prev;
    // 同步队列当前结点的后继结点
    volatile Node next;
    // 当前结点关联的线程
    volatile Thread thread;
    // 独占模式中，表示条件队列中当前结点的后继结点；共享模式中等于常量SHARED
    Node nextWaiter;
}
```

###### ConditionObject

```java
public class ConditionObject implements Condition, java.io.Serializable {
    // 头结点
    private transient Node firstWaiter;
    // 尾结点
    private transient Node lastWaiter;
}
```

###### acquire

```java
// 独占式同步状态的获取
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

// 调用此方法的线程在独占模式下获取对象状态
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}

// 将调用此方法的线程封装成一个结点并放入同步队列
private Node addWaiter(Node mode) {
    // 生成新结点，默认为独占模式
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    // 尾结点不为空
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    // 尾结点为空或node结点入队失败
    enq(node);
    return node;
}

// 将node结点插入到同步队列
private Node enq(final Node node) {
    // 自旋，直到node结点入队成功
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}

// 
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

###### release

```java
// 独占式同步状态的释放
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

##### CountDownLatch

```java

```

##### Semaphore

```java

```



##### CyclicBarrier

```java

```

